<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Parallel Q-Digest: src/qcore.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Parallel Q-Digest
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('qcore_8c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">qcore.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="qcore_8h_source.html">../include/qcore.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memory__utils_8h_source.html">../include/memory_utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="queue_8h_source.html">../include/queue.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a54a31f38410c0938070c6417970f8122" id="r_a54a31f38410c0938070c6417970f8122"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54a31f38410c0938070c6417970f8122">log_2_ceil</a> (size_t n)</td></tr>
<tr class="memdesc:a54a31f38410c0938070c6417970f8122"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes the logarithm base 2 of a number. The ceiling function is applied to return the closest upper integer.  <br /></td></tr>
<tr class="memitem:a9adb83754a20165fb3e333a9f9612331" id="r_a9adb83754a20165fb3e333a9f9612331"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9adb83754a20165fb3e333a9f9612331">create_node</a> (size_t lower_bound, size_t upper_bound)</td></tr>
<tr class="memdesc:a9adb83754a20165fb3e333a9f9612331"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a>, allocating memory for it and initializing its lower and upper bound.  <br /></td></tr>
<tr class="memitem:a0ad12229e43dc27a1c991a35c3512b74" id="r_a0ad12229e43dc27a1c991a35c3512b74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ad12229e43dc27a1c991a35c3512b74">delete_node</a> (struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n)</td></tr>
<tr class="memdesc:a0ad12229e43dc27a1c991a35c3512b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function deletes a node and frees the memory that was allocated to it.  <br /></td></tr>
<tr class="memitem:a516952b951959505916bd5ee4a3064ac" id="r_a516952b951959505916bd5ee4a3064ac"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_q_digest.html">QDigest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a516952b951959505916bd5ee4a3064ac">create_q</a> (struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *root, size_t num_nodes, size_t N, size_t <a class="el" href="main_8c.html#a97d832ae23af4f215e801e37e4f94254">K</a>, size_t num_inserts)</td></tr>
<tr class="memdesc:a516952b951959505916bd5ee4a3064ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>, allocating memory for it and initializing its root, the number of nodes contained, the maximum value of the considered universe (N), the compression parameter (K), and the number of inserts performed.  <br /></td></tr>
<tr class="memitem:a5bd6b8fd9c9a4e9e452cc109940f5d92" id="r_a5bd6b8fd9c9a4e9e452cc109940f5d92"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_q_digest.html">QDigest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bd6b8fd9c9a4e9e452cc109940f5d92">create_tmp_q</a> (size_t <a class="el" href="main_8c.html#a97d832ae23af4f215e801e37e4f94254">K</a>, size_t upper_bound)</td></tr>
<tr class="memdesc:a5bd6b8fd9c9a4e9e452cc109940f5d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a Q-Digest by using some defaults values to mirror the behavior of the class constructor in the original C++ implementation. Specifically it inserts a root node initialized with a lower bound of 0 up to upper_bound. It initializes the num_nodes parameter to 1, and N to 0.  <br /></td></tr>
<tr class="memitem:a9f6a01d56b8708f88f3cf16d43ba11c6" id="r_a9f6a01d56b8708f88f3cf16d43ba11c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f6a01d56b8708f88f3cf16d43ba11c6">free_tree</a> (struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n)</td></tr>
<tr class="memdesc:a9f6a01d56b8708f88f3cf16d43ba11c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function safely frees memory that was dynamically allocated to build the Q-Digest. This effectively acts as a destructor of the struct.  <br /></td></tr>
<tr class="memitem:a83300c21bd8cc5727249cc7a81d4fe8b" id="r_a83300c21bd8cc5727249cc7a81d4fe8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83300c21bd8cc5727249cc7a81d4fe8b">delete_qdigest</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q)</td></tr>
<tr class="memdesc:a83300c21bd8cc5727249cc7a81d4fe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a wrapper function around free_tree that automatically destroys and frees memory from a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct. The function applies free_tree on q-&gt;root.  <br /></td></tr>
<tr class="memitem:ad064406991041115ad0fe0e2c280dbe6" id="r_ad064406991041115ad0fe0e2c280dbe6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad064406991041115ad0fe0e2c280dbe6">node_and_sibling_count</a> (struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n)</td></tr>
<tr class="memdesc:ad064406991041115ad0fe0e2c280dbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the aggregated count for a node and its siblings.  <br /></td></tr>
<tr class="memitem:a3396d04ea939c49a478693a22f146865" id="r_a3396d04ea939c49a478693a22f146865"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3396d04ea939c49a478693a22f146865">delete_node_if_needed</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q, struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n, int level, int l_max)</td></tr>
<tr class="memdesc:a3396d04ea939c49a478693a22f146865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which tree nodes can be deleted. A tree node which has a count of 0 can be deleted only if it has no children. Returns 'true' or 'false' depending on whether it deleted the node n from the tree.  <br /></td></tr>
<tr class="memitem:a6fd311169f046587b57d46672b3c23b7" id="r_a6fd311169f046587b57d46672b3c23b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fd311169f046587b57d46672b3c23b7">compress</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q, struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n, int level, int l_max, size_t nDivk)</td></tr>
<tr class="memdesc:a6fd311169f046587b57d46672b3c23b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function attempts compression on the Q-Digest structure. The function is applied recursively by traversing the left and right subtrees. The function calls <a class="el" href="qcore_8h.html#a3396d04ea939c49a478693a22f146865" title="Determines which tree nodes can be deleted. A tree node which has a count of 0 can be deleted only if...">delete_node_if_needed()</a> to check which nodes should be deleted. If a node has not been deleted, and if the count of itself and its siblings is less than the compression ratio (N/K) then the children nodes are visited and it is checked if they are ready for deletion. By the time the function returns, the Q-Digest has been cleaned of all the nodes that have a low count, thus achieving a degree of compression.  <br /></td></tr>
<tr class="memitem:aee9663d385786c610d4ac67e68cc3abe" id="r_aee9663d385786c610d4ac67e68cc3abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee9663d385786c610d4ac67e68cc3abe">print_tree</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q)</td></tr>
<tr class="memdesc:aee9663d385786c610d4ac67e68cc3abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">q a pointer to a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct whose number of nodes, N, and K parameters will be printed.  <br /></td></tr>
<tr class="memitem:adb5adf5e7db16ecae94162ffe3700316" id="r_adb5adf5e7db16ecae94162ffe3700316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb5adf5e7db16ecae94162ffe3700316">swap_q</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *a, struct <a class="el" href="struct_q_digest.html">QDigest</a> *b)</td></tr>
<tr class="memdesc:adb5adf5e7db16ecae94162ffe3700316"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function swaps the contents of two Q-Digests.  <br /></td></tr>
<tr class="memitem:a7e97980435d2d907cbed1bf27ec9ffbf" id="r_a7e97980435d2d907cbed1bf27ec9ffbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e97980435d2d907cbed1bf27ec9ffbf">compress_if_needed</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q)</td></tr>
<tr class="memdesc:a7e97980435d2d907cbed1bf27ec9ffbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function that gets called directly in most implementations and acts as a wrapper around <a class="el" href="qcore_8h.html#a6fd311169f046587b57d46672b3c23b7" title="This function attempts compression on the Q-Digest structure. The function is applied recursively by ...">compress()</a>. This function automatically computes the compression ratio (nDivk) and the maximum depth of the Q-Digest (l_max). Then <a class="el" href="qcore_8h.html#a6fd311169f046587b57d46672b3c23b7" title="This function attempts compression on the Q-Digest structure. The function is applied recursively by ...">compress()</a> is called on the root node of the Q-Digest.  <br /></td></tr>
<tr class="memitem:aa2c0811b629da7d0af69034b4befcada" id="r_aa2c0811b629da7d0af69034b4befcada"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2c0811b629da7d0af69034b4befcada">expand_tree</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q, size_t upper_bound)</td></tr>
<tr class="memdesc:aa2c0811b629da7d0af69034b4befcada"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function expands a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> whose value universe is too small by embedding its existing tree into a larger <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> with a higher upper bound. The <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> data structure represents values in the range [0, N), where N must be a power of two. When the caller needs to insert a value outside the current universe size, the tree must be expanded so that the digest covers a larger power-of-two range. This function performs that expansion.  <br /></td></tr>
<tr class="memitem:a353f7a0e1cdba9906008561171515863" id="r_a353f7a0e1cdba9906008561171515863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a353f7a0e1cdba9906008561171515863">insert</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q, size_t key, unsigned int count, bool try_compress)</td></tr>
<tr class="memdesc:a353f7a0e1cdba9906008561171515863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value (or multiple occurrences of a value) into a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>.  <br /></td></tr>
<tr class="memitem:a5d8376a2801c0159f1a7833b018a89b6" id="r_a5d8376a2801c0159f1a7833b018a89b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d8376a2801c0159f1a7833b018a89b6">insert_node</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q, const struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n)</td></tr>
<tr class="memdesc:a5d8376a2801c0159f1a7833b018a89b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an existing <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a> into the digest, creating intermediate nodes as needed.  <br /></td></tr>
<tr class="memitem:a1f810632cf9899e3931ab319b90c15ac" id="r_a1f810632cf9899e3931ab319b90c15ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f810632cf9899e3931ab319b90c15ac">postorder_by_rank</a> (struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n, size_t *curr_rank, size_t req_rank)</td></tr>
<tr class="memdesc:a1f810632cf9899e3931ab319b90c15ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a post-order traversal to locate the value associated with a given cumulative rank.  <br /></td></tr>
<tr class="memitem:ad482fe37eed194146172784b3e58b76c" id="r_ad482fe37eed194146172784b3e58b76c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad482fe37eed194146172784b3e58b76c">percentile</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q, double p)</td></tr>
<tr class="memdesc:ad482fe37eed194146172784b3e58b76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the value associated with the p-th percentile of the data stored in the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>.  <br /></td></tr>
<tr class="memitem:a16aa1f7a872be99335caef6193fe9bd1" id="r_a16aa1f7a872be99335caef6193fe9bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16aa1f7a872be99335caef6193fe9bd1">merge</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q1, const struct <a class="el" href="struct_q_digest.html">QDigest</a> *q2)</td></tr>
<tr class="memdesc:a16aa1f7a872be99335caef6193fe9bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the contents of two QDigests into one.  <br /></td></tr>
<tr class="memitem:ac105bb14b2024936d997f5e18cd660b4" id="r_ac105bb14b2024936d997f5e18cd660b4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac105bb14b2024936d997f5e18cd660b4">_digits</a> (size_t value)</td></tr>
<tr class="memdesc:ac105bb14b2024936d997f5e18cd660b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of digits for unsigned int value.  <br /></td></tr>
<tr class="memitem:a4289a94c02292931623f084198deca5f" id="r_a4289a94c02292931623f084198deca5f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4289a94c02292931623f084198deca5f">get_bytes_of_node</a> (struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n)</td></tr>
<tr class="memdesc:a4289a94c02292931623f084198deca5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of bytes required to serialize a node subtree.  <br /></td></tr>
<tr class="memitem:afd6a71b151ce1415ecfe30677ad80b9b" id="r_afd6a71b151ce1415ecfe30677ad80b9b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd6a71b151ce1415ecfe30677ad80b9b">get_num_of_bytes</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q)</td></tr>
<tr class="memdesc:afd6a71b151ce1415ecfe30677ad80b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the buffer size needed to serialize an entire <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>.  <br /></td></tr>
<tr class="memitem:a02e4611ca69cfea9fcbfe241a8a469e3" id="r_a02e4611ca69cfea9fcbfe241a8a469e3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e4611ca69cfea9fcbfe241a8a469e3">preorder_to_string</a> (struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *n, char *buf, size_t *length)</td></tr>
<tr class="memdesc:a02e4611ca69cfea9fcbfe241a8a469e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> tree into a string using preorder traversal.  <br /></td></tr>
<tr class="memitem:a7a79f3bb4cc255b3e9bb54710d805d2d" id="r_a7a79f3bb4cc255b3e9bb54710d805d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a79f3bb4cc255b3e9bb54710d805d2d">to_string</a> (struct <a class="el" href="struct_q_digest.html">QDigest</a> *q, char *buf, size_t *length)</td></tr>
<tr class="memdesc:a7a79f3bb4cc255b3e9bb54710d805d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes an entire <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> into a string representation.  <br /></td></tr>
<tr class="memitem:a4170bb66a23c75cf884abce8256f6a60" id="r_a4170bb66a23c75cf884abce8256f6a60"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="struct_q_digest.html">QDigest</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4170bb66a23c75cf884abce8256f6a60">from_string</a> (char *buf)</td></tr>
<tr class="memdesc:a4170bb66a23c75cf884abce8256f6a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> from a string representation.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ac105bb14b2024936d997f5e18cd660b4" name="ac105bb14b2024936d997f5e18cd660b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac105bb14b2024936d997f5e18cd660b4">&#9670;&#160;</a></span>_digits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _digits </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return number of digits for unsigned int value. </p>
<p>This function initialise a counter to one to then return the number of digits by dividing the value in input by 10 until the current value is less then 10, incrementing the digits counter by one at each steps.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A reference to the value we want to know how many digits it is composed of</td></tr>
    <tr><td class="paramname">digits</td><td>A counter of the number of digits the input value is composed of</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the number of digits the input value is composed of. </dd></dl>

</div>
</div>
<a id="a6fd311169f046587b57d46672b3c23b7" name="a6fd311169f046587b57d46672b3c23b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd311169f046587b57d46672b3c23b7">&#9670;&#160;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compress </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>nDivk</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function attempts compression on the Q-Digest structure. The function is applied recursively by traversing the left and right subtrees. The function calls <a class="el" href="qcore_8h.html#a3396d04ea939c49a478693a22f146865" title="Determines which tree nodes can be deleted. A tree node which has a count of 0 can be deleted only if...">delete_node_if_needed()</a> to check which nodes should be deleted. If a node has not been deleted, and if the count of itself and its siblings is less than the compression ratio (N/K) then the children nodes are visited and it is checked if they are ready for deletion. By the time the function returns, the Q-Digest has been cleaned of all the nodes that have a low count, thus achieving a degree of compression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>a pointer to a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct that should be changed.</td></tr>
    <tr><td class="paramname">n</td><td>a pointer to a <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a> struct from which the search should begin. This is usually the root of the Q-Digest.</td></tr>
    <tr><td class="paramname">level</td><td>an integer representing the current node level of the node in the Q-Digest</td></tr>
    <tr><td class="paramname">l_max</td><td>an integer representing the maximum depth of the Q-Digest</td></tr>
    <tr><td class="paramname">nDivk</td><td>a positive integer representing the compression ratio described in the paper. This makes sure that no nodes with a low count are left in the Q-Digest after compression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e97980435d2d907cbed1bf27ec9ffbf" name="a7e97980435d2d907cbed1bf27ec9ffbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e97980435d2d907cbed1bf27ec9ffbf">&#9670;&#160;</a></span>compress_if_needed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compress_if_needed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function that gets called directly in most implementations and acts as a wrapper around <a class="el" href="qcore_8h.html#a6fd311169f046587b57d46672b3c23b7" title="This function attempts compression on the Q-Digest structure. The function is applied recursively by ...">compress()</a>. This function automatically computes the compression ratio (nDivk) and the maximum depth of the Q-Digest (l_max). Then <a class="el" href="qcore_8h.html#a6fd311169f046587b57d46672b3c23b7" title="This function attempts compression on the Q-Digest structure. The function is applied recursively by ...">compress()</a> is called on the root node of the Q-Digest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>a pointer to a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct to be compressed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9adb83754a20165fb3e333a9f9612331" name="a9adb83754a20165fb3e333a9f9612331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adb83754a20165fb3e333a9f9612331">&#9670;&#160;</a></span>create_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> * create_node </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>lower_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a>, allocating memory for it and initializing its lower and upper bound. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lower_bound</td><td>a positive integer representing the lower bound that can be represented by this node.</td></tr>
    <tr><td class="paramname">upper_bound</td><td>a positive integer representing the upper bound that can be represented by this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a516952b951959505916bd5ee4a3064ac" name="a516952b951959505916bd5ee4a3064ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516952b951959505916bd5ee4a3064ac">&#9670;&#160;</a></span>create_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_q_digest.html">QDigest</a> * create_q </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>root</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_inserts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>, allocating memory for it and initializing its root, the number of nodes contained, the maximum value of the considered universe (N), the compression parameter (K), and the number of inserts performed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>a pointer to a <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a> which will represent the root of the tree.</td></tr>
    <tr><td class="paramname">num_nodes</td><td>an integer representing the number of nodes contained in the Q-Digest.</td></tr>
    <tr><td class="paramname">N</td><td>a positive integer representing the largest possible number that can be stored in the Q-Digest.</td></tr>
    <tr><td class="paramname">K</td><td>an integer representing the compression factor.</td></tr>
    <tr><td class="paramname">num_inserts</td><td>the total number of insertions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bd6b8fd9c9a4e9e452cc109940f5d92" name="a5bd6b8fd9c9a4e9e452cc109940f5d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd6b8fd9c9a4e9e452cc109940f5d92">&#9670;&#160;</a></span>create_tmp_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_q_digest.html">QDigest</a> * create_tmp_q </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>K</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a Q-Digest by using some defaults values to mirror the behavior of the class constructor in the original C++ implementation. Specifically it inserts a root node initialized with a lower bound of 0 up to upper_bound. It initializes the num_nodes parameter to 1, and N to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">K</td><td>a positive integer representing the compression parameter.</td></tr>
    <tr><td class="paramname">upper_bound</td><td>a positive integer representing the maximum range that can contained in the root node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ad12229e43dc27a1c991a35c3512b74" name="a0ad12229e43dc27a1c991a35c3512b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad12229e43dc27a1c991a35c3512b74">&#9670;&#160;</a></span>delete_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function deletes a node and frees the memory that was allocated to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a pointer to a <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3396d04ea939c49a478693a22f146865" name="a3396d04ea939c49a478693a22f146865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3396d04ea939c49a478693a22f146865">&#9670;&#160;</a></span>delete_node_if_needed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool delete_node_if_needed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l_max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which tree nodes can be deleted. A tree node which has a count of 0 can be deleted only if it has no children. Returns 'true' or 'false' depending on whether it deleted the node n from the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>a pointer to the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> which should be affected by the deletion.</td></tr>
    <tr><td class="paramname">n</td><td>a pointer to a <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a> which should be considered for deletion.</td></tr>
    <tr><td class="paramname">level</td><td>implemented for compatibility with the compress function</td></tr>
    <tr><td class="paramname">l_mac</td><td>implemented for compatibility with the compress function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83300c21bd8cc5727249cc7a81d4fe8b" name="a83300c21bd8cc5727249cc7a81d4fe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83300c21bd8cc5727249cc7a81d4fe8b">&#9670;&#160;</a></span>delete_qdigest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_qdigest </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a wrapper function around free_tree that automatically destroys and frees memory from a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct. The function applies free_tree on q-&gt;root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>a pointer to a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct that needs to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2c0811b629da7d0af69034b4befcada" name="aa2c0811b629da7d0af69034b4befcada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c0811b629da7d0af69034b4befcada">&#9670;&#160;</a></span>expand_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void expand_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function expands a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> whose value universe is too small by embedding its existing tree into a larger <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> with a higher upper bound. The <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> data structure represents values in the range [0, N), where N must be a power of two. When the caller needs to insert a value outside the current universe size, the tree must be expanded so that the digest covers a larger power-of-two range. This function performs that expansion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>a pointer to the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct to be expanded</td></tr>
    <tr><td class="paramname">upper_bound</td><td>The new universe size (must be a power of two), and must be strictly larger than the digestâ€™s current upper bound. The expanded digest will represent values in [0, upper_bound). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f6a01d56b8708f88f3cf16d43ba11c6" name="a9f6a01d56b8708f88f3cf16d43ba11c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6a01d56b8708f88f3cf16d43ba11c6">&#9670;&#160;</a></span>free_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function safely frees memory that was dynamically allocated to build the Q-Digest. This effectively acts as a destructor of the struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a pointer to a <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a>. This usually is the root of the Q-Digest since then the function recursively traverses the left and right subtree to free nodes and their contents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4170bb66a23c75cf884abce8256f6a60" name="a4170bb66a23c75cf884abce8256f6a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4170bb66a23c75cf884abce8256f6a60">&#9670;&#160;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="struct_q_digest.html">QDigest</a> * from_string </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deserializes a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> from a string representation. </p>
<p>This function reconstructs a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> from a string previously produced by <span class="tt"><a class="el" href="qcore_8h.html#aacccef5e606069cbf18e500d337268aa" title="Serializes an entire QDigest into a string representation.">to_string()</a></span>. The string is expected to have a header line with digest metadata, followed by lines representing nodes with non-zero counts in preorder.</p>
<p>The header line format is: "&lt;total_count&gt; &lt;K&gt; &lt;root_lower_bound&gt; &lt;root_upper_bound&gt;\n"</p>
<p>Each subsequent line represents a node: "&lt;lower_bound&gt; &lt;upper_bound&gt; &lt;count&gt;\n"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A pointer to a null-terminated string containing the serialized <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly allocated <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> reconstructed from the string, or NULL if the header is invalid. The caller is responsible for freeing the returned digest using <span class="tt"><a class="el" href="qcore_8h.html#a83300c21bd8cc5727249cc7a81d4fe8b" title="This is a wrapper function around free_tree that automatically destroys and frees memory from a QDige...">delete_qdigest()</a></span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function uses <span class="tt"><a class="el" href="qcore_8h.html#a5bd6b8fd9c9a4e9e452cc109940f5d92" title="This function creates a Q-Digest by using some defaults values to mirror the behavior of the class co...">create_tmp_q()</a></span> and <span class="tt"><a class="el" href="qcore_8h.html#a5d8376a2801c0159f1a7833b018a89b6" title="Inserts an existing QDigestNode into the digest, creating intermediate nodes as needed.">insert_node()</a></span> internally to rebuild the tree structure and maintain canonical <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> intervals. </dd>
<dd>
Only nodes with count &gt; 0 are expected in the serialized string. </dd></dl>

</div>
</div>
<a id="a4289a94c02292931623f084198deca5f" name="a4289a94c02292931623f084198deca5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4289a94c02292931623f084198deca5f">&#9670;&#160;</a></span>get_bytes_of_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_bytes_of_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the number of bytes required to serialize a node subtree. </p>
<p>Recursively walks the provided node, summing the number of characters needed to serialize every descendant with a non-zero count, including delimiters between the lower bound, upper bound, and count values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A pointer to the node whose subtree will be measured. NULL returns 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The exact number of bytes required to serialize the subtree rooted at <code class="param">n</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The calculation currently adds a hard-coded 3 bytes for the two spaces and newline that separate the three values in each row. Once we allow configurable delimiters, this literal will be replaced with the length of the delimiter strings provided at runtime. </dd></dl>

</div>
</div>
<a id="afd6a71b151ce1415ecfe30677ad80b9b" name="afd6a71b151ce1415ecfe30677ad80b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6a71b151ce1415ecfe30677ad80b9b">&#9670;&#160;</a></span>get_num_of_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_num_of_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the buffer size needed to serialize an entire <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>. </p>
<p>Sums the bytes required for the header line and all nodes with non-zero counts (by delegating to <span class="tt"><a class="el" href="qcore_8h.html#a4289a94c02292931623f084198deca5f" title="Computes the number of bytes required to serialize a node subtree.">get_bytes_of_node()</a></span>), and includes space for the terminating null byte so callers can pre-allocate an adequate buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Pointer to the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> whose serialized size is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of bytes required for the serialized digest, including the null terminator. Returns 0 if the digest or root is NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The header size calculation currently assumes exactly three spaces and one newline (4 bytes) in the metadata line. This literal will be replaced by the computed length of configurable field separators once we support injecting custom formatting. </dd>
<dd>
Another intereseting update would be that for the explicit +1 for the null terminator to become the length of the caller-provided terminator sequence when we move to dynamic serialization options. </dd></dl>

</div>
</div>
<a id="a353f7a0e1cdba9906008561171515863" name="a353f7a0e1cdba9906008561171515863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353f7a0e1cdba9906008561171515863">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>try_compress</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a value (or multiple occurrences of a value) into a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>. </p>
<p>A <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> represents integer values over a universe [0, N) where N is always a power of two. Each inserted value is routed from the root to the appropriate leaf, creating missing nodes along the path as needed. The node corresponding to the exact key range then has its count increased. Optional post-insertion compression may occur depending on the <span class="tt">try_compress</span> flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A pointer to a struct QDigest* representing the digest into which the value is being inserted.</td></tr>
    <tr><td class="paramname">key</td><td>The integer value to insert. If the key exceeds the digestâ€™s current universe size, the digest is first expanded so that key lies within the new universe range.</td></tr>
    <tr><td class="paramname">count</td><td>How many occurrences of the value to insert. This is added to the count of the leaf node that represents <span class="tt">key</span>.</td></tr>
    <tr><td class="paramname">try_compress</td><td>A boolean flag. If true, the digest may perform a compression pass after insertion. If false, the caller is responsible for periodically calling compression manually. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d8376a2801c0159f1a7833b018a89b6" name="a5d8376a2801c0159f1a7833b018a89b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8376a2801c0159f1a7833b018a89b6">&#9670;&#160;</a></span>insert_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_node </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an existing <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a> into the digest, creating intermediate nodes as needed. </p>
<p>This function takes a node <span class="tt">n</span>â€”typically originating from another digest during merge or expansionâ€”and reproduces its path within the target digest <span class="tt">q</span>. The algorithm walks the tree from the root, descending left or right based on the interval boundaries of <span class="tt">n</span> until it reaches the exact interval <span class="tt">[n-&gt;lower_bound, n-&gt;upper_bound]</span>. Any missing nodes along the path are created to preserve the canonical <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> binary interval structure. Once the corresponding node is located, its count is increased by <span class="tt">n-&gt;count</span>, and the digestâ€™s global count is updated accordingly.</p>
<p>The function assumes that <span class="tt">n</span>â€™s interval is entirely contained within the universe of <span class="tt">q</span>. It does not perform universe expansion; callers must ensure compatibility beforehand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A pointer to the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> into which the node is being inserted.</td></tr>
    <tr><td class="paramname">n</td><td>A pointer to the <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a> whose interval and count are to be merged into the digest <span class="tt">q</span>. The interval [n-&gt;lower_bound, n-&gt;upper_bound] must lie within the current root interval of <span class="tt">q</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54a31f38410c0938070c6417970f8122" name="a54a31f38410c0938070c6417970f8122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a31f38410c0938070c6417970f8122">&#9670;&#160;</a></span>log_2_ceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t log_2_ceil </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function computes the logarithm base 2 of a number. The ceiling function is applied to return the closest upper integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a positive integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16aa1f7a872be99335caef6193fe9bd1" name="a16aa1f7a872be99335caef6193fe9bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16aa1f7a872be99335caef6193fe9bd1">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the contents of two QDigests into one. </p>
<p>This function combines all nodes from <span class="tt">q2</span> into <span class="tt">q1</span>, producing a single <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> that reflects the aggregated counts of both digests. The merge is performed by constructing a temporary <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> <span class="tt">tmp</span> whose universe and compression parameter are chosen to accommodate both inputs:</p>
<ul>
<li>The merged digest uses the <em>maximum</em> K value of <span class="tt">q1</span> and <span class="tt">q2</span>, ensuring that the compression guarantee is no weaker than that of either input.</li>
<li>The root interval (universe size) is expanded to cover the larger of the two digestsâ€™ upper bounds.</li>
</ul>
<p>The function performs a breadth-first traversal of both input digests, pushing every node into <span class="tt">tmp</span> using <span class="tt"><a class="el" href="qcore_8h.html#a5d8376a2801c0159f1a7833b018a89b6" title="Inserts an existing QDigestNode into the digest, creating intermediate nodes as needed.">insert_node()</a></span>. This operation reconstructs the canonical <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> structure while summing the counts of corresponding intervals.</p>
<p>Once all nodes have been inserted, a compression pass is applied to restore <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> invariants. Finally, <span class="tt">q1</span> is replaced with the merged digest, and all temporary structures are freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>A pointer to the destination <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>. After the merge, <span class="tt">q1</span> contains the combined contents of both digests.</td></tr>
    <tr><td class="paramname">q2</td><td>A pointer to the source <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>. Its nodes are read but not modified. All key ranges and counts from <span class="tt">q2</span> are inserted into the merged digest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function does not modify <span class="tt">q2</span>; it may continue to be used independently after the merge.</dd>
<dd>
The resulting digestâ€™s accuracy guarantees follow the stronger (i.e., larger K) of the two original digests. </dd></dl>

</div>
</div>
<a id="ad064406991041115ad0fe0e2c280dbe6" name="ad064406991041115ad0fe0e2c280dbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad064406991041115ad0fe0e2c280dbe6">&#9670;&#160;</a></span>node_and_sibling_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t node_and_sibling_count </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the aggregated count for a node and its siblings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a pointer to a <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad482fe37eed194146172784b3e58b76c" name="ad482fe37eed194146172784b3e58b76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad482fe37eed194146172784b3e58b76c">&#9670;&#160;</a></span>percentile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t percentile </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the value associated with the p-th percentile of the data stored in the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>. </p>
<p>This function uses the cumulative count of values stored in the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> to estimate a percentile. Given a percentile <span class="tt">p</span> in the range [0, 1], the function calculates the corresponding rank (i.e., the number of elements that must be accumulated to reach that percentile) and then performs a post-order traversal of the digest to locate the value whose cumulative frequency first meets or exceeds that rank.</p>
<p>Internally, this delegates the search to <span class="tt"><a class="el" href="qcore_8h.html#a1f810632cf9899e3931ab319b90c15ac" title="Performs a post-order traversal to locate the value associated with a given cumulative rank.">postorder_by_rank()</a></span>, which walks the digest in increasing-value order and returns the upper_bound of the node associated with the requested rank. Because <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> nodes represent value ranges, the returned value corresponds to the endpoint of the interval in which the percentile falls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A pointer to the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> from which the percentile is computed.</td></tr>
    <tr><td class="paramname">p</td><td>A floating-point percentile value in the range [0, 1]. For example, 0.5 corresponds to the median, 0.9 to the 90th percentile, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the p-th percentile. This is determined by finding the smallest value whose cumulative rank satisfies <span class="tt">rank &gt;= p * q-&gt;N</span>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <span class="tt">q</span> is empty (i.e., q-&gt;N == 0), the behavior is undefined. The caller must ensure that the digest contains data before requesting a percentile. </dd></dl>

</div>
</div>
<a id="a1f810632cf9899e3931ab319b90c15ac" name="a1f810632cf9899e3931ab319b90c15ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f810632cf9899e3931ab319b90c15ac">&#9670;&#160;</a></span>postorder_by_rank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t postorder_by_rank </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>curr_rank</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>req_rank</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a post-order traversal to locate the value associated with a given cumulative rank. </p>
<p>This function walks the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> tree in post-order (left subtree, right subtree, then node itself) while maintaining a running count of the cumulative frequency of visited nodes. The cumulative count is tracked externally through <span class="tt">curr_rank</span>, which is incremented by each nodeâ€™s count as the traversal progresses.</p>
<p>The goal is to determine the smallest value whose cumulative rank meets or exceeds <span class="tt">req_rank</span>. When that condition becomes true, the function returns the upper_bound of the node that satisfied it, representing the value associated with the quantile or rank query.</p>
<p>This is a utility commonly used to answer quantile queries in <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a>, where nodes represent aggregated ranges and are visited in an order consistent with increasing value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A pointer to the current <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a> being inspected. A NULL pointer causes the function to return 0 immediately.</td></tr>
    <tr><td class="paramname">curr_rank</td><td>A pointer to a counter tracking the cumulative rank accumulated so far. This value is incremented by <span class="tt">n-&gt;count</span> when the node is processed.</td></tr>
    <tr><td class="paramname">req_rank</td><td>The target cumulative rank for which we are searching. Once <span class="tt">*curr_rank</span> reaches or exceeds this value, the traversal unwinds and returns the corresponding node's upper_bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The upper_bound of the node whose cumulative rank first meets or exceeds <span class="tt">req_rank</span>. Returns 0 if the subtree is empty. </dd></dl>

</div>
</div>
<a id="a02e4611ca69cfea9fcbfe241a8a469e3" name="a02e4611ca69cfea9fcbfe241a8a469e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e4611ca69cfea9fcbfe241a8a469e3">&#9670;&#160;</a></span>preorder_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * preorder_to_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest_node.html">QDigestNode</a> *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>buf_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> tree into a string using preorder traversal. </p>
<p>This function walks the <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a> tree in preorder (node first, then left child, then right child) and writes the non-zero counts of each node into a provided buffer. Each line of the output contains the node's lower bound, upper bound, and count, separated by spaces.</p>
<p>The function updates the buffer pointer as it writes, and also increments the total length of the string written so far.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>A pointer to the current <a class="el" href="struct_q_digest_node.html" title="A struct representing a node in the Q-Digest data structure.">QDigestNode</a>. If NULL, the function returns immediately without modifying the buffer.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to the character buffer where the serialized output is appended. The caller must ensure the buffer is large enough to hold the resulting string.</td></tr>
    <tr><td class="paramname">length</td><td>A pointer to a size_t variable that tracks the total number of characters written to the buffer. This is updated in-place as nodes are serialized.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the position in the buffer immediately after the last character written. This allows recursive calls to continue writing from the correct location.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only nodes with count &gt; 0 are included in the output. </dd>
<dd>
The output format for each node is: "&lt;lower_bound&gt; &lt;upper_bound&gt; &lt;count&gt;\n" </dd></dl>

</div>
</div>
<a id="aee9663d385786c610d4ac67e68cc3abe" name="aee9663d385786c610d4ac67e68cc3abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9663d385786c610d4ac67e68cc3abe">&#9670;&#160;</a></span>print_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_tree </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>q a pointer to a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct whose number of nodes, N, and K parameters will be printed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>a pointer to a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb5adf5e7db16ecae94162ffe3700316" name="adb5adf5e7db16ecae94162ffe3700316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5adf5e7db16ecae94162ffe3700316">&#9670;&#160;</a></span>swap_q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap_q </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function swaps the contents of two Q-Digests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>pointer to a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct to be swapped</td></tr>
    <tr><td class="paramname">b</td><td>pointer to a <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> struct to be swapped </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a79f3bb4cc255b3e9bb54710d805d2d" name="a7a79f3bb4cc255b3e9bb54710d805d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a79f3bb4cc255b3e9bb54710d805d2d">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void to_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_q_digest.html">QDigest</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>buf_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes an entire <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> into a string representation. </p>
<p>This function writes the metadata of the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> followed by the preorder traversal of all nodes with non-zero counts. The output is suitable for saving or debugging the digest.</p>
<p>The first line contains the digest-level metadata: "&lt;total_count&gt; &lt;K&gt; &lt;root_lower_bound&gt; &lt;root_upper_bound&gt;\n"</p>
<p>Each subsequent line represents a node with count &gt; 0, in preorder: "&lt;lower_bound&gt; &lt;upper_bound&gt; &lt;count&gt;\n"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>A pointer to the <a class="el" href="struct_q_digest.html" title="A struct representing the Q-Digest data structure.">QDigest</a> to serialize.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a character buffer where the string output will be written. The caller must ensure it is large enough to hold the entire serialized digest.</td></tr>
    <tr><td class="paramname">length</td><td>A pointer to a size_t variable that tracks the total number of characters written into the buffer. This is updated in-place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The serialization includes only nodes with count &gt; 0. </dd>
<dd>
The function relies on <span class="tt"><a class="el" href="qcore_8h.html#af13645e2c712991ce1eab3bfd0a5a187" title="Serializes a QDigest tree into a string using preorder traversal.">preorder_to_string()</a></span> to serialize the nodes recursively after writing the metadata. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a href="qcore_8c.html">qcore.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
